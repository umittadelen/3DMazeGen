<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            border: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            z-index: 0;
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 2;
        }

        #upload, #urlBtn, #base64Btn, #genBtn {
            padding: 10px 20px;
            background: rgba(30, 30, 30, 0.8);
            color: #fff;
            border: 2px solid #666;
            cursor: pointer;
            font-size: 16px;
        }

        #upload:hover, #urlBtn:hover, #base64Btn:hover, #genBtn:hover {
            background: rgba(70, 70, 70, 0.8);
        }

        #genBtn {
            background: rgba(50, 100, 50, 0.8);
        }

        #genBtn:hover {
            background: rgba(70, 130, 70, 0.8);
        }

        #urlInput, #base64Input {
            display: none;
            padding: 8px;
            width: 300px;
            background: rgba(30, 30, 30, 0.9);
            color: #fff;
            border: 2px solid #666;
            font-size: 14px;
        }

        #urlInput::placeholder, #base64Input::placeholder {
            color: #999;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 8px;
            z-index: 2;
        }

        .win {
            color: #0f0;
            font-size: 24px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        .error {
            color: #f00;
            font-size: 14px;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="controls">
            <button id="genBtn" onclick="location.href='gen.html'">ðŸŽ¨ Generate Maze</button>
            <input type="file" id="upload" accept="image/*">
            <div class="input-group">
                <button id="urlBtn">Load from URL</button>
                <input type="text" id="urlInput" placeholder="Enter image URL and press Enter...">
            </div>
            <div class="input-group">
                <button id="base64Btn">Load from Base64</button>
                <input type="text" id="base64Input" placeholder="Paste base64 string and press Enter...">
            </div>
        </div>
        <canvas id="canvas" width="800" height="600"></canvas>
        <div id="info">Load a maze image to start. Use WASD or Arrow keys to move, Mouse to look around.</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('info');
        const upload = document.getElementById('upload');
        const urlBtn = document.getElementById('urlBtn');
        const urlInput = document.getElementById('urlInput');
        const base64Btn = document.getElementById('base64Btn');
        const base64Input = document.getElementById('base64Input');

        let maze = null;
        let mazeWidth = 0;
        let mazeHeight = 0;
        let playerX = 0;
        let playerY = 0;
        let playerAngle = 0;
        let goalX = 0;
        let goalY = 0;
        let won = false;
        let running = false;

        let playerPitch = 0;
        const MAX_PITCH = Math.PI / 2 * 0.99;

        let FOV = Math.PI / 3;
        const NUM_RAYS = 800;
        const MAX_DEPTH = 50;
        const MOVE_SPEED = 0.025;
        const ROT_SPEED = 0.025;

        const keys = {};
        let mouseLocked = false;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function hideControls() {
            document.getElementById('controls').style.display = 'none';
            canvas.requestPointerLock();
        }

        function showError(message) {
            info.innerHTML = `<span class="error">Error: ${message}</span>`;
            setTimeout(() => {
                info.innerHTML = 'Load a maze image to start. Use WASD or Arrow keys to move, Mouse to look around.';
            }, 3000);
        }

        // File upload
        upload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    loadMaze(img);
                    hideControls();
                };
                img.onerror = () => showError('Failed to load image file');
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // URL upload
        urlBtn.addEventListener('click', () => {
            urlInput.style.display = urlInput.style.display === 'none' ? 'block' : 'none';
            base64Input.style.display = 'none';
            if (urlInput.style.display === 'block') {
                urlInput.focus();
            }
        });

        urlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const url = urlInput.value.trim();
                if (!url) {
                    showError('Please enter a URL');
                    return;
                }

                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    loadMaze(img);
                    hideControls();
                };
                img.onerror = () => showError('Failed to load image from URL. Check CORS or URL validity.');
                img.src = url;
            }
        });

        // Base64 upload
        base64Btn.addEventListener('click', () => {
            base64Input.style.display = base64Input.style.display === 'none' ? 'block' : 'none';
            urlInput.style.display = 'none';
            if (base64Input.style.display === 'block') {
                base64Input.focus();
            }
        });

        base64Input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                let base64 = base64Input.value.trim();
                if (!base64) {
                    showError('Please paste a base64 string');
                    return;
                }

                // Add data URL prefix if not present
                if (!base64.startsWith('data:')) {
                    base64 = 'data:image/png;base64,' + base64;
                }

                const img = new Image();
                img.onload = () => {
                    loadMaze(img);
                    hideControls();
                };
                img.onerror = () => showError('Invalid base64 image data');
                img.src = base64;
            }
        });

        function loadMaze(img) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const pixels = imageData.data;

            mazeWidth = img.width;
            mazeHeight = img.height;
            maze = new Uint8Array(mazeWidth * mazeHeight);

            let foundStart = false;
            let foundGoal = false;

            // Parse maze: 0=wall, 1=path, 2=start, 3=goal
            for (let i = 0; i < pixels.length; i += 4) {
                const idx = i / 4;
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];

                if (r > 200 && g < 50 && b < 50) {
                    maze[idx] = 2; // Start (red)
                    playerX = (idx % mazeWidth) + 0.5;
                    playerY = Math.floor(idx / mazeWidth) + 0.5;
                    foundStart = true;
                } else if (r < 50 && g > 200 && b < 50) {
                    maze[idx] = 3; // Goal (green)
                    goalX = (idx % mazeWidth) + 0.5;
                    goalY = Math.floor(idx / mazeWidth) + 0.5;
                    foundGoal = true;
                } else if (r > 200 && g > 200 && b > 200) {
                    maze[idx] = 1; // Path (white)
                } else {
                    maze[idx] = 0; // Wall (black)
                }
            }

            if (!foundStart || !foundGoal) {
                showError('Maze must have a red start point and green goal point');
                return;
            }

            won = false;
            info.innerHTML = 'Find the green goal! WASD/Arrows to move, Mouse to look. Hold x to run.';
            requestAnimationFrame(gameLoop);
        }

        function isWall(x, y) {
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            if (ix < 0 || ix >= mazeWidth || iy < 0 || iy >= mazeHeight) return true;
            return maze[iy * mazeWidth + ix] === 0;
        }

        function checkGoal() {
            const dx = playerX - goalX;
            const dy = playerY - goalY;
            if (dx * dx + dy * dy < 0.5) {
                won = true;
                info.innerHTML = '<span class="win">ðŸŽ‰ YOU WON! ðŸŽ‰</span>';
            }
        }

        function castRay(angle) {
            const dx = Math.cos(angle);
            const dy = Math.sin(angle);

            let dist = 0;
            let hitType = 0;

            for (let i = 0; i < MAX_DEPTH * 100; i++) {
                dist += 0.01;
                const x = playerX + dx * dist;
                const y = playerY + dy * dist;

                const ix = Math.floor(x);
                const iy = Math.floor(y);

                if (ix < 0 || ix >= mazeWidth || iy < 0 || iy >= mazeHeight) {
                    hitType = 0;
                    break;
                }

                const cell = maze[iy * mazeWidth + ix];
                if (cell === 0) {
                    hitType = 0;
                    break;
                } else if (cell === 3) {
                    hitType = 3;
                    break;
                }
            }

            return { dist, hitType };
        }

        function render() {
            const centerY = canvas.height / 2 + playerPitch * canvas.height / 2;
            // Sky
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, centerY);

            // Ground
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, centerY, canvas.width, canvas.height - centerY);

            // Cast rays
            for (let i = 0; i < NUM_RAYS; i++) {
                const rayAngle = playerAngle - FOV / 2 + (FOV * i) / NUM_RAYS;
                const { dist, hitType } = castRay(rayAngle);

                const correctedDist = dist * Math.cos(rayAngle - playerAngle);
                const wallHeight = canvas.height / correctedDist;

                const fog = Math.min(1, correctedDist / MAX_DEPTH);

                let r = 200, g = 200, b = 200;
                if (hitType === 3) {
                    r = 0; g = 255; b = 0;
                }

                const fogColor = { r: 10, g: 20, b: 40 };
                const fogFactor = Math.min(1, fog * 5);
                r = Math.floor(r * (1 - fogFactor) + fogColor.r * fogFactor);
                g = Math.floor(g * (1 - fogFactor) + fogColor.g * fogFactor);
                b = Math.floor(b * (1 - fogFactor) + fogColor.b * fogFactor);

                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                const x = (i * canvas.width) / NUM_RAYS;
                const centerY = canvas.height / 2 + playerPitch * canvas.height / 2;
                const y = centerY - wallHeight / 2;
                ctx.fillRect(x, y, canvas.width / NUM_RAYS + 1, wallHeight);
            }
        }

        function applyIGNDithering(ctx, canvas) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;

                    const dot = x * 0.06711056 + y * 0.00583715;
                    let noise = 52.9829189 * (dot - Math.floor(dot));
                    noise = (noise - Math.floor(noise)) * 255 - 127.5;
                    const n = noise * 0.015;

                    data[i] = Math.max(0, Math.min(255, data[i] + n));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + n));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + n));
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        let needsRender = true;

        function update() {
            if (won) return;

            let moveX = 0;
            let moveY = 0;
            let movedOrRotated = false;

            let speed = MOVE_SPEED;
            if (running) speed *= 2;

            if (keys['w'] || keys['arrowup']) {
                moveX += Math.cos(playerAngle) * speed;
                moveY += Math.sin(playerAngle) * speed;
            }
            if (keys['s'] || keys['arrowdown']) {
                moveX -= Math.cos(playerAngle) * speed;
                moveY -= Math.sin(playerAngle) * speed;
            }
            if (keys['a']) {
                moveX += Math.cos(playerAngle - Math.PI / 2) * speed;
                moveY += Math.sin(playerAngle - Math.PI / 2) * speed;
            }
            if (keys['d']) {
                moveX += Math.cos(playerAngle + Math.PI / 2) * speed;
                moveY += Math.sin(playerAngle + Math.PI / 2) * speed;
            }

            if (keys['ArrowLeft']) {
                playerAngle -= ROT_SPEED;
                movedOrRotated = true;
            }
            if (keys['ArrowRight']) {
                playerAngle += ROT_SPEED;
                movedOrRotated = true;
            }

            const buffer = 0.2;
            const newX = playerX + moveX;
            const newY = playerY + moveY;

            let actuallyMoved = false;

            if (!isWall(newX + (moveX > 0 ? buffer : -buffer), playerY)) {
                playerX = newX;
                actuallyMoved = true;
            }
            if (!isWall(playerX, newY + (moveY > 0 ? buffer : -buffer))) {
                playerY = newY;
                actuallyMoved = true;
            }

            movedOrRotated = movedOrRotated || actuallyMoved;

            checkGoal();

            needsRender = movedOrRotated;
        }

        function gameLoop() {
            update();
            if (needsRender) {
                render();
                applyIGNDithering(ctx, canvas);
            }
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;

            if (e.key === "x") running = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;

            if (e.key === "x") running = false;
        });

        canvas.addEventListener('click', () => {
            if (!mouseLocked) canvas.requestPointerLock();
        });



        document.addEventListener('mousemove', (e) => {
            if (mouseLocked) {
                playerAngle += e.movementX * 0.002;
                playerPitch -= e.movementY * 0.004;
                if (playerPitch > MAX_PITCH) playerPitch = MAX_PITCH;
                if (playerPitch < -MAX_PITCH) playerPitch = -MAX_PITCH;
                needsRender = true;
            }
        });

        // Clear all keys when window loses focus or pointer lock is lost
        window.addEventListener('blur', () => {
            Object.keys(keys).forEach(key => keys[key] = false);
            running = false;
        });

        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === canvas;
            if (!mouseLocked) {
                // Clear all keys when pointer lock is lost
                Object.keys(keys).forEach(key => keys[key] = false);
                running = false;
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                Object.keys(keys).forEach(key => keys[key] = false);
                running = false;
            }
        });
    </script>
</body>

</html>